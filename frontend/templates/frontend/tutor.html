{% extends "base.html" %}

{% block title %}Hangul Typing Tutor{% endblock %}

{% block extra_css %}
    <meta name="csrf-token" content="{{ csrf_token }}">
{% endblock %}

{% block content %}
    <div id="root"></div>
{% endblock %}

{% block extra_js %}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <script type="text/babel">
        const csrftoken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
        function decomposeHangul(char) {
            const syllableStart = 44032;
            const syllableEnd = 55203;
            const code = char.charCodeAt(0);

            if (code < syllableStart || code > syllableEnd) {
                return [char];
            }

            const chosung = Math.floor((code - syllableStart) / 588);
            const jungsung = Math.floor((code - syllableStart - chosung * 588) / 28);
            const jongsung = (code - syllableStart - chosung * 588 - jungsung * 28);

            const chosungList = 'ㄱㄲㄴㄷㄸㄹㅁㅂㅃㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎ';
            const jungsungList = 'ㅏㅐㅑㅒㅓㅔㅕㅖㅗㅘㅙㅚㅛㅜㅝㅞㅟㅠㅡㅢㅣ';
            const jongsungList = 'ㄱㄲㄳㄴㄵㄶㄷㄹㄺㄻㄼㄽㄾㄿㅀㅁㅂㅄㅅㅆㅇㅈㅊㅋㅌㅍㅎ';

            const result = [chosungList[chosung], jungsungList[jungsung]];
            if (jongsung > 0) {
                result.push(jongsungList[jongsung - 1]);
            }

            return result;
        }

        function KoreanKeyboard({ pressedKey, isCorrect }) {
            const getKeyColor = (key) => {
                if (key === pressedKey) {
                    return isCorrect ? "#4CAF50" : "#FF5252";
                }
                return "#d4d4d4";
            };

            const renderKey = (x, y, main, sub = null) => (
                <g transform={`translate(${x}, ${y})`}>
                    <rect width="70" height="70" fill={getKeyColor(main)} />
                    <text x="35" y="40" textAnchor="middle" fontSize="20">{main}</text>
                    {sub && <text x="55" y="25" textAnchor="middle" fontSize="16">{sub}</text>}
                </g>
            );

            return (
                <svg viewBox="0 0 800 380" className="w-full max-w-2xl mx-auto mb-4">
                    <rect width="800" height="380" fill="#f0f0f0" />
                    {/* First row */}
                    {renderKey(10, 10, 'ㅂ', 'ㅃ')}
                    {renderKey(90, 10, 'ㅈ', 'ㅉ')}
                    {renderKey(170, 10, 'ㄷ', 'ㄸ')}
                    {renderKey(250, 10, 'ㄱ', 'ㄲ')}
                    {renderKey(330, 10, 'ㅅ', 'ㅆ')}
                    {renderKey(410, 10, 'ㅛ')}
                    {renderKey(490, 10, 'ㅕ')}
                    {renderKey(570, 10, 'ㅑ')}
                    {renderKey(650, 10, 'ㅐ', 'ㅒ')}
                    {renderKey(730, 10, 'ㅔ', 'ㅖ')}
                    {/* Second row */}
                    {renderKey(50, 90, 'ㅁ')}
                    {renderKey(130, 90, 'ㄴ')}
                    {renderKey(210, 90, 'ㅇ')}
                    {renderKey(290, 90, 'ㄹ')}
                    {renderKey(370, 90, 'ㅎ')}
                    {renderKey(450, 90, 'ㅗ')}
                    {renderKey(530, 90, 'ㅓ')}
                    {renderKey(610, 90, 'ㅏ')}
                    {renderKey(690, 90, 'ㅣ')}
                    {/* Third row */}
                    {renderKey(90, 170, 'ㅋ')}
                    {renderKey(170, 170, 'ㅌ')}
                    {renderKey(250, 170, 'ㅊ')}
                    {renderKey(330, 170, 'ㅍ')}
                    {renderKey(410, 170, 'ㅠ')}
                    {renderKey(490, 170, 'ㅜ')}
                    {renderKey(570, 170, 'ㅡ')}
                    {/* Spacebar */}
                    <g transform="translate(170, 250)">
                        <rect width="460" height="70" fill={getKeyColor(' ')} />
                        <text x="230" y="40" textAnchor="middle" fontSize="20">Space</text>
                    </g>
                </svg>
            );
        }

        function App() {
            const [challengeGroups, setChallengeGroups] = React.useState([]);
            const [currentGroup, setCurrentGroup] = React.useState(null);
            const [challengeIds, setChallengeIds] = React.useState([]);
            const [currentChallengeIndex, setCurrentChallengeIndex] = React.useState(0);
            const [currentChallenge, setCurrentChallenge] = React.useState(null);
            const [input, setInput] = React.useState('');
            const [startTime, setStartTime] = React.useState(null);
            const [spm, setSpm] = React.useState(0);
            const [showEnglish, setShowEnglish] = React.useState(false);
            const [pressedKey, setPressedKey] = React.useState(null);
            const [isCorrectKey, setIsCorrectKey] = React.useState(false);
            const [debug, setDebug] = React.useState('');
            const [lastInputLength, setLastInputLength] = React.useState(0);
            const [correctKeystrokes, setCorrectKeystrokes] = React.useState(0);
            const [totalKeystrokes, setTotalKeystrokes] = React.useState(0);
            const [accuracy, setAccuracy] = React.useState(0);
            const [showAccuracy, setShowAccuracy] = React.useState(false);
            const [isChallengeLoaded, setIsChallengeLoaded] = React.useState(false);

            const inputRef = React.useRef(null);

            React.useEffect(() => {
                fetchChallengeGroups();
            }, []);

            React.useEffect(() => {
                if (currentGroup) {
                    setChallengeIds(currentGroup.challenges);
                    setCurrentChallengeIndex(0);
                }
            }, [currentGroup]);

            React.useEffect(() => {
                if (challengeIds.length > 0 && currentChallengeIndex < challengeIds.length) {
                    fetchChallenge(challengeIds[currentChallengeIndex]);
                }
            }, [challengeIds, currentChallengeIndex]);

            React.useEffect(() => {
                if (challengeIds.length > 0 && currentChallengeIndex < challengeIds.length) {
                    fetchChallenge(challengeIds[currentChallengeIndex]);
                }
            }, [challengeIds, currentChallengeIndex]);

            React.useEffect(() => {
                if (isChallengeLoaded && inputRef.current) {
                    inputRef.current.focus();
                }
            }, [isChallengeLoaded]);

            const fetchChallenge = async (challengeId) => {
                try {
                    const response = await fetch(
                        `../api/v1/challenges/${challengeId}`,
                        {
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrftoken
                            }
                        }
                    );
                    if (!response.ok) {
                        throw new Error('Failed to fetch challenge');
                    }
                    const data = await response.json();
                    setCurrentChallenge(data);
                    setIsChallengeLoaded(true);
                } catch (error) {
                    console.error('Error fetching challenge:', error);
                    setDebug('Error fetching challenge. Please try again.');
                }
            };

            const fetchChallengeGroups = async () => {
                try {
                    const response = await fetch(
                        '../api/v1/challenge_groups/',
                        {
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrftoken
                            }
                        }
                    );
                    if (!response.ok) {
                        throw new Error('Failed to fetch challenge groups');
                    }
                    const data = await response.json();
                    setChallengeGroups(data);
                    if (data.length > 0) {
                        setCurrentGroup(data[0]);
                    }
                } catch (error) {
                    console.error('Error fetching challenge groups:', error);
                    setDebug('Error fetching challenge groups. Please try again.');
                }
            };

            const handleInputChange = (e) => {
                const newInput = e.target.value;
                if (!startTime) {
                    setStartTime(Date.now());
                }
                setInput(newInput);

                let lastChar;
                if (newInput.length > lastInputLength) {
                    lastChar = newInput.slice(-1);
                } else {
                    lastChar = newInput.slice(-1);
                    const decomposed = decomposeHangul(lastChar);
                    lastChar = decomposed[decomposed.length - 1];
                }
                setLastInputLength(newInput.length);

                const expectedChar = currentChallenge.hangul[newInput.length - 1];

                const decomposedExpected = decomposeHangul(expectedChar);
                const decomposedInput = decomposeHangul(newInput.slice(-1));

                const isCorrect = decomposedExpected.slice(0, decomposedInput.length).every((char, index) => char === decomposedInput[index]);

                setPressedKey(lastChar);
                setIsCorrectKey(isCorrect);

                setTotalKeystrokes(prev => prev + 1);
                if (isCorrect) {
                    setCorrectKeystrokes(prev => prev + 1);
                }

                setDebug(`Input: ${newInput}, Last input: ${lastChar}, Expected: ${expectedChar}, Correct: ${isCorrect}`);

                if (newInput === currentChallenge.hangul) {
                    const endTime = Date.now();
                    const timeInMinutes = (endTime - startTime) / 60000;
                    const symbolsTyped = currentChallenge.hangul.length;
                    const calculatedSpm = Math.round(symbolsTyped / timeInMinutes);
                    const calculatedAccuracy = Math.round((correctKeystrokes / totalKeystrokes) * 100);

                    setSpm(calculatedSpm);
                    setAccuracy(calculatedAccuracy);
                    setShowEnglish(true);
                    setShowAccuracy(true);

                    // Send typing speed data to the backend
                    fetch('../api/v1/typing-speeds/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrftoken
                        },
                        body: JSON.stringify({
                            challenge: currentChallenge.id,
                            speed: calculatedSpm,
                            accuracy: calculatedAccuracy
                        })
                    }).then(response => response.json())
                        .then(data => console.log('Typing speed saved:', data))
                        .catch(error => console.error('Error saving typing speed:', error));

                    setTimeout(() => {
                        const nextIndex = (currentChallengeIndex + 1) % challengeIds.length;
                        setCurrentChallengeIndex(nextIndex);
                        setIsChallengeLoaded(false);
                        setInput('');
                        setStartTime(null);
                        setShowEnglish(false);
                        setLastInputLength(0);
                        setCorrectKeystrokes(0);
                        setTotalKeystrokes(0);
                        setShowAccuracy(false);
                        setPressedKey(null);
                        setIsCorrectKey(false);
                    }, 5000);
                }
            };

            const handlePaste = (e) => {
                e.preventDefault();
            };

            if (!currentChallenge) {
                return <div className="text-center mt-10">Loading challenge...</div>;
            }

            return (
                <div className="container mx-auto mt-10 p-4">
                    <h1 className="text-3xl font-bold mb-6 text-center">Hangul Typing Tutor</h1>
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <KoreanKeyboard pressedKey={pressedKey} isCorrect={isCorrectKey} />
                        <p className="text-2xl mb-4 text-center">{currentChallenge.hangul}</p>
                        {showEnglish && (
                            <p className="text-xl mb-4 text-center text-green-600">{currentChallenge.english}</p>
                        )}
                        <input
                            ref={inputRef}
                            type="text"
                            value={input}
                            onChange={handleInputChange}
                            onPaste={handlePaste}
                            className="w-full p-2 border rounded mb-4"
                            placeholder="Type the Hangul here"
                        />
                        {spm > 0 && (
                            <div className="text-center">
                                <p className="text-blue-600">Your typing speed: {spm} Symbols Per Minute</p>
                                {showAccuracy && <p className="text-green-600">Accuracy: {accuracy}%</p>}
                            </div>
                        )}
                        <p className="text-sm text-gray-500 mt-2">{debug}</p>
                    </div>
                    <TypingHistory />
                </div>
            );
        }

        function TypingHistory() {
            const [history, setHistory] = React.useState([]);

            React.useEffect(() => {
                fetch('../api/v1/typing-speeds/')
                    .then(response => response.json())
                    .then(data => setHistory(data))
                    .catch(error => console.error('Error fetching typing history:', error));
            }, []);

            return (
                <div className="mt-8">
                    <h2 className="text-xl font-bold mb-4">Your Typing History</h2>
                    <table className="w-full">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Speed (SPM)</th>
                                <th>Accuracy (%)</th>
                            </tr>
                        </thead>
                        <tbody>
                            {history.map(entry => (
                                <tr key={entry.id}>
                                    <td>{new Date(entry.timestamp).toLocaleString()}</td>
                                    <td>{entry.speed}</td>
                                    <td>{entry.accuracy}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
{% endblock %}
